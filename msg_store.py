"""
Interact with RabbitMQ persistent message store
"""

import pathlib
from typing import List
import typer
from term import codec
from model import Message, message_from_decoded_etf


def parse_rdq_file(filepath: pathlib.Path) -> List[Message]:
    """Parse a .rdq file generated by RabbitMQ and recover all messages stored inside along with some headers like the routing information"""

    file_length = filepath.stat().st_size
    parsed_messages = []

    with filepath.open("rb") as input_file:
        while input_file.tell() < file_length:
            # Each serialized message has a prefix that contains its size on 8 bytes and its id on 16 bytes
            # See https://github.com/rabbitmq/rabbitmq-server/blob/master/deps/rabbit/src/rabbit_msg_file.erl#L45
            message_size = int.from_bytes(input_file.read(8), byteorder="big")
            message_id = int.from_bytes(input_file.read(16), byteorder="big")

            # The size contains the message length plus the message id length, so we need to substract the message id length
            message = input_file.read(message_size - 16)

            # Each message has a suffix of one byte that should always be FF
            message_suffix = input_file.read(1)
            if message_suffix != b"\xff":
                typer.secho(
                    f"Message suffix is not FF. Aborting recovery for this file.",
                    fg=typer.colors.RED,
                )
                continue

            # The message itself is serialized in Erlang External Term Format
            # Complete reference: https://erlang.org/doc/apps/erts/erl_ext_dist.html
            decoded_message = codec.binary_to_term(message)

            structured_message = message_from_decoded_etf(message_id, decoded_message)

            parsed_messages.append(structured_message)

    return parsed_messages
